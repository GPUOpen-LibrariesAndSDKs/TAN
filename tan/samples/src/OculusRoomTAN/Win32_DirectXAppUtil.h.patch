27a28
> #include <new>
73a75
>         Tex->Release();
108,118c110,120
< 	HWND                     Window;
< 	bool                     Running;
< 	bool                     Key[256];
< 	int                      WinSizeW;
< 	int                      WinSizeH;
< 	ID3D11Device           * Device;
< 	ID3D11DeviceContext    * Context;
< 	IDXGISwapChain         * SwapChain;
< 	DepthBuffer            * MainDepthBuffer;
< 	ID3D11Texture2D        * BackBuffer;
< 	ID3D11RenderTargetView * BackBufferRT;
---
>     HWND                     Window;
>     bool                     Running;
>     bool                     Key[256];
>     int                      WinSizeW;
>     int                      WinSizeH;
>     ID3D11Device           * Device;
>     ID3D11DeviceContext    * Context;
>     IDXGISwapChain         * SwapChain;
>     DepthBuffer            * MainDepthBuffer;
>     ID3D11Texture2D        * BackBuffer;
>     ID3D11RenderTargetView * BackBufferRT;
121,122c123,124
< 	unsigned char            UniformData[UNIFORM_DATA_SIZE];
< 	DataBuffer             * UniformBufferGen;
---
>     unsigned char            UniformData[UNIFORM_DATA_SIZE];
>     DataBuffer             * UniformBufferGen;
125,126c127,128
< 	static LRESULT CALLBACK WindowProc(_In_ HWND hWnd, _In_ UINT Msg, _In_ WPARAM wParam, _In_ LPARAM lParam)
< 	{
---
>     static LRESULT CALLBACK WindowProc(_In_ HWND hWnd, _In_ UINT Msg, _In_ WPARAM wParam, _In_ LPARAM lParam)
>     {
147c149
< 	}
---
>     }
163,164c165,166
< 		// Clear input
< 		for (int i = 0; i < sizeof(Key)/sizeof(Key[0]); ++i)
---
>         // Clear input
>         for (int i = 0; i < sizeof(Key)/sizeof(Key[0]); ++i)
169c171
< 	{
---
>     {
175c177
< 	{
---
>     {
177c179
< 		Running = true;
---
>         Running = true;
179c181
< 		WNDCLASSW wc;
---
>         WNDCLASSW wc;
181,185c183,187
< 		wc.lpszClassName = L"App";
< 		wc.style = CS_OWNDC;
< 		wc.lpfnWndProc = WindowProc;
< 		wc.cbWndExtra = sizeof(this);
< 		RegisterClassW(&wc);
---
>         wc.lpszClassName = L"App";
>         wc.style = CS_OWNDC;
>         wc.lpfnWndProc = WindowProc;
>         wc.cbWndExtra = sizeof(this);
>         RegisterClassW(&wc);
188c190
< 		Window = CreateWindowW(wc.lpszClassName, title, WS_OVERLAPPEDWINDOW, 0, 0, 0, 0, 0, 0, hinst, 0);
---
>         Window = CreateWindowW(wc.lpszClassName, title, WS_OVERLAPPEDWINDOW, 0, 0, 0, 0, 0, 0, hinst, 0);
191c193
< 		SetWindowLongPtr(Window, 0, LONG_PTR(this));
---
>         SetWindowLongPtr(Window, 0, LONG_PTR(this));
194c196
< 	}
---
>     }
200,202c202,204
< 	        DestroyWindow(Window);
< 	        Window = nullptr;
< 	        UnregisterClassW(L"App", hInstance);
---
>             DestroyWindow(Window);
>             Window = nullptr;
>             UnregisterClassW(L"App", hInstance);
206,209c208,214
<     bool InitDevice(int vpW, int vpH, const LUID* pLuid, bool windowed = true)
< 	{
< 		WinSizeW = vpW;
< 		WinSizeH = vpH;
---
>     bool InitDevice(int vpW, int vpH, const LUID* pLuid, bool windowed = true, int scale = 1)
>     {
>         WinSizeW = vpW;
>         WinSizeH = vpH;
> 
>         if (scale == 0)
>             scale = 1;
211,212c216,217
< 		RECT size = { 0, 0, vpW, vpH };
< 		AdjustWindowRect(&size, WS_OVERLAPPEDWINDOW, false);
---
>         RECT size = { 0, 0, vpW / scale, vpH / scale};
>         AdjustWindowRect(&size, WS_OVERLAPPEDWINDOW, false);
217,218c222,223
< 		IDXGIFactory * DXGIFactory = nullptr;
< 		HRESULT hr = CreateDXGIFactory1(__uuidof(IDXGIFactory), (void**)(&DXGIFactory));
---
>         IDXGIFactory * DXGIFactory = nullptr;
>         HRESULT hr = CreateDXGIFactory1(__uuidof(IDXGIFactory), (void**)(&DXGIFactory));
221c226
< 		IDXGIAdapter * Adapter = nullptr;
---
>         IDXGIAdapter * Adapter = nullptr;
232c237
< 		hr = D3D11CreateDevice(Adapter, DriverType, 0, 0, 0, 0, D3D11_SDK_VERSION, &Device, 0, &Context);
---
>         hr = D3D11CreateDevice(Adapter, DriverType, 0, 0, 0, 0, D3D11_SDK_VERSION, &Device, 0, &Context);
236,237c241,242
< 		// Create swap chain
< 		DXGI_SWAP_CHAIN_DESC scDesc;
---
>         // Create swap chain
>         DXGI_SWAP_CHAIN_DESC scDesc;
239,249c244,254
< 		scDesc.BufferCount = 2;
< 		scDesc.BufferDesc.Width = WinSizeW;
< 		scDesc.BufferDesc.Height = WinSizeH;
< 		scDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
< 		scDesc.BufferDesc.RefreshRate.Denominator = 1;
< 		scDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
< 		scDesc.OutputWindow = Window;
< 		scDesc.SampleDesc.Count = 1;
< 		scDesc.Windowed = windowed;
< 		scDesc.SwapEffect = DXGI_SWAP_EFFECT_SEQUENTIAL;
< 		hr = DXGIFactory->CreateSwapChain(Device, &scDesc, &SwapChain);
---
>         scDesc.BufferCount = 2;
>         scDesc.BufferDesc.Width = WinSizeW;
>         scDesc.BufferDesc.Height = WinSizeH;
>         scDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
>         scDesc.BufferDesc.RefreshRate.Denominator = 1;
>         scDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
>         scDesc.OutputWindow = Window;
>         scDesc.SampleDesc.Count = 1;
>         scDesc.Windowed = windowed;
>         scDesc.SwapEffect = DXGI_SWAP_EFFECT_SEQUENTIAL;
>         hr = DXGIFactory->CreateSwapChain(Device, &scDesc, &SwapChain);
253,255c258,260
< 		// Create backbuffer
< 		SwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (void**)&BackBuffer);
< 		hr = Device->CreateRenderTargetView(BackBuffer, NULL, &BackBufferRT);
---
>         // Create backbuffer
>         SwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (void**)&BackBuffer);
>         hr = Device->CreateRenderTargetView(BackBuffer, NULL, &BackBufferRT);
258,260c263,265
< 		// Main depth buffer
< 		MainDepthBuffer = new DepthBuffer(Device, WinSizeW, WinSizeH);
< 		Context->OMSetRenderTargets(1, &BackBufferRT, MainDepthBuffer->TexDsv);
---
>         // Main depth buffer
>         MainDepthBuffer = new DepthBuffer(Device, WinSizeW, WinSizeH);
>         Context->OMSetRenderTargets(1, &BackBufferRT, MainDepthBuffer->TexDsv);
262c267
< 		// Buffer for shader constants
---
>         // Buffer for shader constants
264c269
< 		Context->VSSetConstantBuffers(0, 1, &UniformBufferGen->D3DBuffer);
---
>         Context->VSSetConstantBuffers(0, 1, &UniformBufferGen->D3DBuffer);
266,270c271,273
< 		// Set max frame latency to 1
< 		IDXGIDevice1* DXGIDevice1 = nullptr;
< 	    hr = Device->QueryInterface(__uuidof(IDXGIDevice1), (void**)&DXGIDevice1);
< 		DXGIDevice1->SetMaximumFrameLatency(1);
< 		Release(DXGIDevice1);
---
>         // Set max frame latency to 1
>         IDXGIDevice1* DXGIDevice1 = nullptr;
>         hr = Device->QueryInterface(__uuidof(IDXGIDevice1), (void**)&DXGIDevice1);
271a275,276
>         DXGIDevice1->SetMaximumFrameLatency(1);
>         Release(DXGIDevice1);
274c279
< 	}
---
>     }
276,302c281,308
< 	void SetAndClearRenderTarget(ID3D11RenderTargetView * rendertarget, struct DepthBuffer * depthbuffer, float R = 0, float G = 0, float B = 0, float A = 0)
< 	{
< 		float black[] = { R, G, B, A }; // Important that alpha=0, if want pixels to be transparent, for manual layers
< 		Context->OMSetRenderTargets(1, &rendertarget, depthbuffer->TexDsv);
< 		Context->ClearRenderTargetView(rendertarget, black);
< 		Context->ClearDepthStencilView(depthbuffer->TexDsv, D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1, 0);
< 	}
< 
< 	void SetViewport(float vpX, float vpY, float vpW, float vpH)
< 	{
< 		D3D11_VIEWPORT D3Dvp;
< 		D3Dvp.Width = vpW;    D3Dvp.Height = vpH;
< 		D3Dvp.MinDepth = 0;   D3Dvp.MaxDepth = 1;
< 		D3Dvp.TopLeftX = vpX; D3Dvp.TopLeftY = vpY;
< 		Context->RSSetViewports(1, &D3Dvp);
< 	}
< 
< 	bool HandleMessages(void)
< 	{
< 		MSG msg;
< 		while (PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE))
< 		{
< 			TranslateMessage(&msg);
< 			DispatchMessage(&msg);
< 		}
< 		// This is to provide a means to terminate after a maximum number of frames
< 		// to facilitate automated testing
---
>     void SetAndClearRenderTarget(ID3D11RenderTargetView * rendertarget, struct DepthBuffer * depthbuffer, float R = 0, float G = 0, float B = 0, float A = 0)
>     {
>         float black[] = { R, G, B, A }; // Important that alpha=0, if want pixels to be transparent, for manual layers
>         Context->OMSetRenderTargets(1, &rendertarget, (depthbuffer ? depthbuffer->TexDsv : nullptr));
>         Context->ClearRenderTargetView(rendertarget, black);
>         if(depthbuffer)
>             Context->ClearDepthStencilView(depthbuffer->TexDsv, D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1, 0);
>     }
> 
>     void SetViewport(float vpX, float vpY, float vpW, float vpH)
>     {
>         D3D11_VIEWPORT D3Dvp;
>         D3Dvp.Width = vpW;    D3Dvp.Height = vpH;
>         D3Dvp.MinDepth = 0;   D3Dvp.MaxDepth = 1;
>         D3Dvp.TopLeftX = vpX; D3Dvp.TopLeftY = vpY;
>         Context->RSSetViewports(1, &D3Dvp);
>     }
> 
>     bool HandleMessages(void)
>     {
>         MSG msg;
>         while (PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE))
>         {
>             TranslateMessage(&msg);
>             DispatchMessage(&msg);
>         }
>         // This is to provide a means to terminate after a maximum number of frames
>         // to facilitate automated testing
304,305c310,314
< 		    if (--maxFrames <= 0)
< 			    Running = false;
---
>             if (maxFrames > 0)
>             {
>                 if (--maxFrames <= 0)
>                     Running = false;
>             }
307,308c316,317
< 		return Running;
< 	}
---
>         return Running;
>     }
324,325c333,334
< 	void ReleaseDevice()
< 	{
---
>     void ReleaseDevice()
>     {
339c348
< 	}
---
>     }
348,351c357,360
< 	ID3D11Texture2D            * Tex;
< 	ID3D11ShaderResourceView   * TexSv;
< 	ID3D11RenderTargetView     * TexRtv;
< 	int                          SizeW, SizeH, MipLevels;
---
>     ID3D11Texture2D            * Tex;
>     ID3D11ShaderResourceView   * TexSv;
>     ID3D11RenderTargetView     * TexRtv;
>     int                          SizeW, SizeH, MipLevels;
353,354c362,363
< 	enum { AUTO_WHITE = 1, AUTO_WALL, AUTO_FLOOR, AUTO_CEILING, AUTO_GRID, AUTO_GRADE_256 };
< 	Texture() : Tex(nullptr), TexSv(nullptr), TexRtv(nullptr) {};
---
>     enum { AUTO_WHITE = 1, AUTO_WALL, AUTO_FLOOR, AUTO_CEILING, AUTO_GRID, AUTO_GRADE_256 };
>     Texture() : Tex(nullptr), TexSv(nullptr), TexRtv(nullptr) {};
361,373c370,382
< 		D3D11_TEXTURE2D_DESC dsDesc;
< 		dsDesc.Width = SizeW;
< 		dsDesc.Height = SizeH;
< 		dsDesc.MipLevels = MipLevels;
< 		dsDesc.ArraySize = 1;
< 		dsDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
< 		dsDesc.SampleDesc.Count = sampleCount;
< 		dsDesc.SampleDesc.Quality = 0;
< 		dsDesc.Usage = D3D11_USAGE_DEFAULT;
< 		dsDesc.CPUAccessFlags = 0;
< 		dsDesc.MiscFlags = 0;
< 		dsDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
< 		if (rendertarget) dsDesc.BindFlags |= D3D11_BIND_RENDER_TARGET;
---
>         D3D11_TEXTURE2D_DESC dsDesc;
>         dsDesc.Width = SizeW;
>         dsDesc.Height = SizeH;
>         dsDesc.MipLevels = MipLevels;
>         dsDesc.ArraySize = 1;
>         dsDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
>         dsDesc.SampleDesc.Count = sampleCount;
>         dsDesc.SampleDesc.Quality = 0;
>         dsDesc.Usage = D3D11_USAGE_DEFAULT;
>         dsDesc.CPUAccessFlags = 0;
>         dsDesc.MiscFlags = 0;
>         dsDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
>         if (rendertarget) dsDesc.BindFlags |= D3D11_BIND_RENDER_TARGET;
375,376c384,385
< 		DIRECTX.Device->CreateTexture2D(&dsDesc, NULL, &Tex);
< 		DIRECTX.Device->CreateShaderResourceView(Tex, NULL, &TexSv);
---
>         DIRECTX.Device->CreateTexture2D(&dsDesc, NULL, &Tex);
>         DIRECTX.Device->CreateShaderResourceView(Tex, NULL, &TexSv);
378c387
< 		if (rendertarget) DIRECTX.Device->CreateRenderTargetView(Tex, NULL, &TexRtv);
---
>         if (rendertarget) DIRECTX.Device->CreateRenderTargetView(Tex, NULL, &TexRtv);
380,381c389,390
< 	Texture(int sizeW, int sizeH, bool rendertarget, int mipLevels = 1, int sampleCount = 1)
< 	{
---
>     Texture(int sizeW, int sizeH, bool rendertarget, int mipLevels = 1, int sampleCount = 1)
>     {
383,385c392,394
< 	}
< 	Texture(bool rendertarget, int sizeW, int sizeH, int autoFillData = 0, int sampleCount = 1)
< 	{
---
>     }
>     Texture(bool rendertarget, int sizeW, int sizeH, int autoFillData = 0, int sampleCount = 1)
>     {
387,388c396,397
< 		if (autoFillData) AutoFillTexture(autoFillData);
< 	}
---
>         if (autoFillData) AutoFillTexture(autoFillData);
>     }
396,454c405,464
< 	void FillTexture(DWORD * pix)
< 	{
< 		//Make local ones, because will be reducing them
< 		int sizeW = SizeW; 
< 		int sizeH = SizeH;
< 		for (int level = 0; level < MipLevels; level++)
< 		{
< 			DIRECTX.Context->UpdateSubresource(Tex, level, NULL, (unsigned char *)pix, sizeW * 4, sizeH * 4);
< 
< 			for (int j = 0; j < (sizeH & ~1); j += 2)
< 			{
< 				uint8_t* psrc = (uint8_t *)pix + (sizeW * j * 4);
< 				uint8_t* pdest = (uint8_t *)pix + (sizeW * j);
< 				for (int i = 0; i < sizeW >> 1; i++, psrc += 8, pdest += 4)
< 				{
< 					pdest[0] = (((int)psrc[0]) + psrc[4] + psrc[sizeW * 4 + 0] + psrc[sizeW * 4 + 4]) >> 2;
< 					pdest[1] = (((int)psrc[1]) + psrc[5] + psrc[sizeW * 4 + 1] + psrc[sizeW * 4 + 5]) >> 2;
< 					pdest[2] = (((int)psrc[2]) + psrc[6] + psrc[sizeW * 4 + 2] + psrc[sizeW * 4 + 6]) >> 2;
< 					pdest[3] = (((int)psrc[3]) + psrc[7] + psrc[sizeW * 4 + 3] + psrc[sizeW * 4 + 7]) >> 2;
< 				}
< 			}
< 			sizeW >>= 1;  sizeH >>= 1;
< 		}
< 	}
< 
< 	static void ConvertToSRGB(DWORD * linear)
< 	{
< 		DWORD drgb[3];
< 		for (int k = 0; k < 3; k++)
< 		{
< 			float rgb = ((float)((*linear >> (k * 8)) & 0xff)) / 255.0f;
< 			rgb = pow(rgb, 2.2f);
< 			drgb[k] = (DWORD)(rgb * 255.0f);
< 		}
< 		*linear = (*linear & 0xff000000) + (drgb[2] << 16) + (drgb[1] << 8) + (drgb[0] << 0);
< 	}
< 
< 	void AutoFillTexture(int autoFillData)
< 	{
< 		DWORD * pix = (DWORD *)malloc(sizeof(DWORD) *  SizeW * SizeH);
< 		for (int j = 0; j < SizeH; j++)
< 		for (int i = 0; i < SizeW; i++)
< 		{
< 			DWORD * curr = &pix[j*SizeW + i];
< 			switch (autoFillData)
< 			{
< 			case(AUTO_WALL) : *curr = (((j / 4 & 15) == 0) || (((i / 4 & 15) == 0) && ((((i / 4 & 31) == 0) ^ ((j / 4 >> 4) & 1)) == 0))) ?
< 				0xff3c3c3c : 0xffb4b4b4; break;
< 			case(AUTO_FLOOR) : *curr = (((i >> 7) ^ (j >> 7)) & 1) ? 0xffb4b4b4 : 0xff505050; break;
< 			case(AUTO_CEILING) : *curr = (i / 4 == 0 || j / 4 == 0) ? 0xff505050 : 0xffb4b4b4; break;
< 			case(AUTO_WHITE) : *curr = 0xffffffff;              break;
< 			case(AUTO_GRADE_256) : *curr = 0xff000000 + i*0x010101;              break;
< 			case(AUTO_GRID) : *curr = (i<4) || (i>(SizeW - 5)) || (j<4) || (j>(SizeH - 5)) ? 0xffffffff : 0xff000000; break;
< 			default: *curr = 0xffffffff;              break;
< 			}
< 			///ConvertToSRGB(curr); //Require format for SDK - I've been recommended to remove for now.
< 		}
< 		FillTexture(pix);
< 	}
---
>     void FillTexture(uint32_t * pix)
>     {
>         //Make local ones, because will be reducing them
>         int sizeW = SizeW; 
>         int sizeH = SizeH;
>         for (int level = 0; level < MipLevels; level++)
>         {
>             DIRECTX.Context->UpdateSubresource(Tex, level, NULL, (unsigned char *)pix, sizeW * 4, sizeH * sizeW * 4);
> 
>             for (int j = 0; j < (sizeH & ~1); j += 2)
>             {
>                 uint8_t* psrc = (uint8_t *)pix + (sizeW * j * 4);
>                 uint8_t* pdest = (uint8_t *)pix + (sizeW * j);
>                 for (int i = 0; i < sizeW >> 1; i++, psrc += 8, pdest += 4)
>                 {
>                     pdest[0] = (((int)psrc[0]) + psrc[4] + psrc[sizeW * 4 + 0] + psrc[sizeW * 4 + 4]) >> 2;
>                     pdest[1] = (((int)psrc[1]) + psrc[5] + psrc[sizeW * 4 + 1] + psrc[sizeW * 4 + 5]) >> 2;
>                     pdest[2] = (((int)psrc[2]) + psrc[6] + psrc[sizeW * 4 + 2] + psrc[sizeW * 4 + 6]) >> 2;
>                     pdest[3] = (((int)psrc[3]) + psrc[7] + psrc[sizeW * 4 + 3] + psrc[sizeW * 4 + 7]) >> 2;
>                 }
>             }
>             sizeW >>= 1;  sizeH >>= 1;
>         }
>     }
> 
>     static void ConvertToSRGB(uint32_t * linear)
>     {
>         uint32_t drgb[3];
>         for (int k = 0; k < 3; k++)
>         {
>             float rgb = ((float)((*linear >> (k * 8)) & 0xff)) / 255.0f;
>             rgb = pow(rgb, 2.2f);
>             drgb[k] = (uint32_t)(rgb * 255.0f);
>         }
>         *linear = (*linear & 0xff000000) + (drgb[2] << 16) + (drgb[1] << 8) + (drgb[0] << 0);
>     }
> 
>     void AutoFillTexture(int autoFillData)
>     {
>         uint32_t * pix = (uint32_t *)malloc(sizeof(uint32_t) *  SizeW * SizeH);
>         for (int j = 0; j < SizeH; j++)
>             for (int i = 0; i < SizeW; i++)
>             {
>                 uint32_t * curr = &pix[j*SizeW + i];
>                 switch (autoFillData)
>                 {
>                 case(AUTO_WALL) : *curr = (((j / 4 & 15) == 0) || (((i / 4 & 15) == 0) && ((((i / 4 & 31) == 0) ^ ((j / 4 >> 4) & 1)) == 0))) ?
>                     0xff3c3c3c : 0xffb4b4b4; break;
>                 case(AUTO_FLOOR) : *curr = (((i >> 7) ^ (j >> 7)) & 1) ? 0xffb4b4b4 : 0xff505050;   break;
>                 case(AUTO_CEILING) : *curr = (i / 4 == 0 || j / 4 == 0) ? 0xff505050 : 0xffb4b4b4;  break;
>                 case(AUTO_WHITE) : *curr = 0xffffffff;                                              break;
>                 case(AUTO_GRADE_256) : *curr = 0xff000000 + i*0x010101;                             break;
>                 case(AUTO_GRID) : *curr = (i<4) || (i>(SizeW - 5)) || (j<4) || (j>(SizeH - 5)) ? 0xffffffff : 0xff000000; break;
>                 default: *curr = 0xffffffff;              break;
>                 }
>             }
> 
>         FillTexture(pix);
>         free(pix);
>     }
460,544c470,588
< 	ID3D11VertexShader      * D3DVert;
< 	ID3D11PixelShader       * D3DPix;
< 	Texture                 * Tex;
< 	ID3D11InputLayout       * InputLayout;
< 	UINT                      VertexSize;
< 	ID3D11SamplerState      * SamplerState;
< 	ID3D11RasterizerState   * Rasterizer;
< 	ID3D11DepthStencilState * DepthState;
< 	ID3D11BlendState        * BlendState;
< 
< 	enum { MAT_WRAP = 1, MAT_WIRE = 2, MAT_ZALWAYS = 4, MAT_NOCULL = 8 , MAT_TRANS = 16};
< 	Material(Texture * t, DWORD flags = MAT_WRAP | MAT_TRANS, D3D11_INPUT_ELEMENT_DESC * vertexDesc = NULL, int numVertexDesc = 3,
< 		char* vertexShader = NULL, char* pixelShader = NULL, int vSize = 24) : Tex(t), VertexSize(vSize)
< 	{
< 		D3D11_INPUT_ELEMENT_DESC defaultVertexDesc[] = {
< 			{ "Position", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
< 			{ "Color",    0, DXGI_FORMAT_B8G8R8A8_UNORM,  0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },
< 			{ "TexCoord", 0, DXGI_FORMAT_R32G32_FLOAT,    0, 16, D3D11_INPUT_PER_VERTEX_DATA, 0 }, };
< 
< 		// Use defaults if no shaders specified
< 		char* defaultVertexShaderSrc =
< 			"float4x4 ProjView;  float4 MasterCol;"
< 			"void main(in  float4 Position  : POSITION,    in  float4 Color : COLOR0, in  float2 TexCoord  : TEXCOORD0,"
< 			"          out float4 oPosition : SV_Position, out float4 oColor: COLOR0, out float2 oTexCoord : TEXCOORD0)"
< 			"{   oPosition = mul(ProjView, Position); oTexCoord = TexCoord; "
< 			"    oColor = MasterCol * Color; }"; 
< 		char* defaultPixelShaderSrc =
< 			"Texture2D Texture   : register(t0); SamplerState Linear : register(s0); "
< 			"float4 main(in float4 Position : SV_Position, in float4 Color: COLOR0, in float2 TexCoord : TEXCOORD0) : SV_Target"
< 			"{   float4 TexCol = Texture.Sample(Linear, TexCoord); "
< 			"    if (TexCol.a==0) clip(-1); " // If alpha = 0, don't draw
< 			"    return(Color * TexCol); }";
< 
< 		if (!vertexDesc)   vertexDesc = defaultVertexDesc;
< 		if (!vertexShader) vertexShader = defaultVertexShaderSrc;
< 		if (!pixelShader)  pixelShader = defaultPixelShaderSrc;
< 
< 		// Create vertex shader
< 		ID3DBlob * blobData;
< 		D3DCompile(vertexShader, strlen(vertexShader), 0, 0, 0, "main", "vs_4_0", 0, 0, &blobData, 0);
< 		DIRECTX.Device->CreateVertexShader(blobData->GetBufferPointer(), blobData->GetBufferSize(), NULL, &D3DVert);
< 
< 		// Create input layout
< 		DIRECTX.Device->CreateInputLayout(vertexDesc, numVertexDesc,
< 			blobData->GetBufferPointer(), blobData->GetBufferSize(), &InputLayout); 
< 		blobData->Release();
< 
< 		// Create pixel shader
< 		D3DCompile(pixelShader, strlen(pixelShader), 0, 0, 0, "main", "ps_4_0", 0, 0, &blobData, 0);
< 		DIRECTX.Device->CreatePixelShader(blobData->GetBufferPointer(), blobData->GetBufferSize(), NULL, &D3DPix);
< 		blobData->Release();
< 
< 		// Create sampler state
< 		D3D11_SAMPLER_DESC ss; memset(&ss, 0, sizeof(ss));
< 		ss.AddressU = ss.AddressV = ss.AddressW = flags & MAT_WRAP ? D3D11_TEXTURE_ADDRESS_WRAP : D3D11_TEXTURE_ADDRESS_BORDER;
< 		ss.Filter = D3D11_FILTER_ANISOTROPIC;
< 		ss.MaxAnisotropy = 8;
< 		ss.MaxLOD = 15;
< 		DIRECTX.Device->CreateSamplerState(&ss, &SamplerState);
< 
< 		// Create rasterizer
< 		D3D11_RASTERIZER_DESC rs; memset(&rs, 0, sizeof(rs));
< 		rs.AntialiasedLineEnable = rs.DepthClipEnable = true;
< 		rs.CullMode = flags & MAT_NOCULL ? D3D11_CULL_NONE : D3D11_CULL_BACK;
< 		rs.FillMode = flags & MAT_WIRE ? D3D11_FILL_WIREFRAME : D3D11_FILL_SOLID;
< 		DIRECTX.Device->CreateRasterizerState(&rs, &Rasterizer);
< 
< 		// Create depth state
< 		D3D11_DEPTH_STENCIL_DESC dss;
< 		memset(&dss, 0, sizeof(dss));
< 		dss.DepthEnable = true;
< 		dss.DepthFunc = flags & MAT_ZALWAYS ? D3D11_COMPARISON_ALWAYS : D3D11_COMPARISON_LESS;
< 		dss.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
< 		DIRECTX.Device->CreateDepthStencilState(&dss, &DepthState);
< 
< 		//Create blend state - trans or otherwise
< 		D3D11_BLEND_DESC bm;
< 		memset(&bm, 0, sizeof(bm));
< 		bm.RenderTarget[0].BlendEnable = flags & MAT_TRANS ? true : false;
< 		bm.RenderTarget[0].BlendOp = bm.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;
< 		bm.RenderTarget[0].SrcBlend = bm.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_SRC_ALPHA;
< 		bm.RenderTarget[0].DestBlend = bm.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_INV_SRC_ALPHA;
< 		bm.RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
< 		DIRECTX.Device->CreateBlendState(&bm, &BlendState);
< 	}
---
>     ID3D11VertexShader      * VertexShader, *VertexShaderInstanced;
>     ID3D11PixelShader       * PixelShader;
>     Texture                 * Tex;
>     ID3D11InputLayout       * InputLayout;
>     UINT                      VertexSize;
>     ID3D11SamplerState      * SamplerState;
>     ID3D11RasterizerState   * Rasterizer;
>     ID3D11DepthStencilState * DepthState;
>     ID3D11BlendState        * BlendState;
> 
>     enum { MAT_WRAP = 1, MAT_WIRE = 2, MAT_ZALWAYS = 4, MAT_NOCULL = 8 , MAT_TRANS = 16};
>     Material(Texture * t, uint32_t flags = MAT_WRAP | MAT_TRANS, D3D11_INPUT_ELEMENT_DESC * vertexDesc = NULL, int numVertexDesc = 3,
>         char* vertexShader = NULL, char* pixelShader = NULL, int vSize = 24) : Tex(t), VertexSize(vSize)
>     {
>         D3D11_INPUT_ELEMENT_DESC defaultVertexDesc[] = {
>             { "Position", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
>             { "Color",    0, DXGI_FORMAT_B8G8R8A8_UNORM,  0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },
>             { "TexCoord", 0, DXGI_FORMAT_R32G32_FLOAT,    0, 16, D3D11_INPUT_PER_VERTEX_DATA, 0 }, };
> 
>         // Use defaults if no shaders specified
>         char* defaultVertexShaderSrc =
>             "float4x4 ProjView;  float4 MasterCol;"
>             "void main(in  float4 Position  : POSITION,    in  float4 Color : COLOR0, in  float2 TexCoord  : TEXCOORD0,"
>             "          out float4 oPosition : SV_Position, out float4 oColor: COLOR0, out float2 oTexCoord : TEXCOORD0)"
>             "{   oPosition = mul(ProjView, Position); oTexCoord = TexCoord; "
>             "    oColor = MasterCol * Color; }"; 
>         char* defaultPixelShaderSrc =
>             "Texture2D Texture   : register(t0); SamplerState Linear : register(s0); "
>             "float4 main(in float4 Position : SV_Position, in float4 Color: COLOR0, in float2 TexCoord : TEXCOORD0) : SV_Target"
>             "{   float4 TexCol = Texture.Sample(Linear, TexCoord); "
>             "    if (TexCol.a==0) clip(-1); " // If alpha = 0, don't draw
>             "    return(Color * TexCol); }";
> 
>         // vertex shader for instanced stereo
>         char* instancedStereoVertexShaderSrc =
>             "float4x4 modelViewProj[2];  float4 MasterCol;"
>             "void main(in  float4 Position  : POSITION,    in  float4 Color : COLOR0, in  float2 TexCoord  : TEXCOORD0,"
>             "          in  uint instanceID : SV_InstanceID, "
>             "          out float4 oPosition : SV_Position, out float4 oColor: COLOR0, out float2 oTexCoord : TEXCOORD0,"
>             "          out float oClipDist : SV_ClipDistance0, out float oCullDist : SV_CullDistance0)"
>             "{"
>             "   const float4 EyeClipPlane[2] = { { -1, 0, 0, 0 }, { 1, 0, 0, 0 } };"
>             "   uint eyeIndex = instanceID & 1;"
>             // transform to clip space for correct eye (includes offset and scale)
>             "   oPosition = mul(modelViewProj[eyeIndex], Position); "
>             // calculate distance from left/right clip plane (try setting to 0 to see why clipping is necessary)
>             "   oCullDist = oClipDist = dot(EyeClipPlane[eyeIndex], oPosition);"
>             "   oTexCoord = TexCoord; "
>             "   oColor = MasterCol * Color;"
>             "}";
> 
>         if (!vertexDesc)   vertexDesc = defaultVertexDesc;
>         if (!vertexShader) vertexShader = defaultVertexShaderSrc;
>         if (!pixelShader)  pixelShader = defaultPixelShaderSrc;
> 
>         // Create vertex shader
>         ID3DBlob * blobData;
>         ID3DBlob * errorBlob = nullptr;
>         HRESULT result = D3DCompile(vertexShader, strlen(vertexShader), 0, 0, 0, "main", "vs_4_0", 0, 0, &blobData, &errorBlob);
>         if (FAILED(result))
>         {
>             MessageBoxA(NULL, (char *)errorBlob->GetBufferPointer(), "Error compiling vertex shader", MB_OK);
>             exit(-1);
>         }
>         DIRECTX.Device->CreateVertexShader(blobData->GetBufferPointer(), blobData->GetBufferSize(), NULL, &VertexShader);
> 
>         // Create input layout
>         DIRECTX.Device->CreateInputLayout(vertexDesc, numVertexDesc,
>             blobData->GetBufferPointer(), blobData->GetBufferSize(), &InputLayout);
>         blobData->Release();
> 
>         // Create vertex shader for instancing
>         result = D3DCompile(instancedStereoVertexShaderSrc, strlen(instancedStereoVertexShaderSrc), 0, 0, 0, "main", "vs_4_0", 0, 0, &blobData, &errorBlob);
>         if (FAILED(result))
>         {
>             MessageBoxA(NULL, (char *)errorBlob->GetBufferPointer(), "Error compiling vertex shader", MB_OK);
>             exit(-1);
>         }
>         DIRECTX.Device->CreateVertexShader(blobData->GetBufferPointer(), blobData->GetBufferSize(), NULL, &VertexShaderInstanced);
>         blobData->Release();
> 
>         // Create pixel shader
>         D3DCompile(pixelShader, strlen(pixelShader), 0, 0, 0, "main", "ps_4_0", 0, 0, &blobData, 0);
>         DIRECTX.Device->CreatePixelShader(blobData->GetBufferPointer(), blobData->GetBufferSize(), NULL, &PixelShader);
>         blobData->Release();
> 
>         // Create sampler state
>         D3D11_SAMPLER_DESC ss; memset(&ss, 0, sizeof(ss));
>         ss.AddressU = ss.AddressV = ss.AddressW = flags & MAT_WRAP ? D3D11_TEXTURE_ADDRESS_WRAP : D3D11_TEXTURE_ADDRESS_BORDER;
>         ss.Filter = D3D11_FILTER_ANISOTROPIC;
>         ss.MaxAnisotropy = 8;
>         ss.MaxLOD = 15;
>         DIRECTX.Device->CreateSamplerState(&ss, &SamplerState);
> 
>         // Create rasterizer
>         D3D11_RASTERIZER_DESC rs; memset(&rs, 0, sizeof(rs));
>         rs.AntialiasedLineEnable = rs.DepthClipEnable = true;
>         rs.CullMode = flags & MAT_NOCULL ? D3D11_CULL_NONE : D3D11_CULL_BACK;
>         rs.FillMode = flags & MAT_WIRE ? D3D11_FILL_WIREFRAME : D3D11_FILL_SOLID;
>         DIRECTX.Device->CreateRasterizerState(&rs, &Rasterizer);
> 
>         // Create depth state
>         D3D11_DEPTH_STENCIL_DESC dss;
>         memset(&dss, 0, sizeof(dss));
>         dss.DepthEnable = true;
>         dss.DepthFunc = flags & MAT_ZALWAYS ? D3D11_COMPARISON_ALWAYS : D3D11_COMPARISON_LESS;
>         dss.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
>         DIRECTX.Device->CreateDepthStencilState(&dss, &DepthState);
> 
>         //Create blend state - trans or otherwise
>         D3D11_BLEND_DESC bm;
>         memset(&bm, 0, sizeof(bm));
>         bm.RenderTarget[0].BlendEnable = flags & MAT_TRANS ? true : false;
>         bm.RenderTarget[0].BlendOp = bm.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;
>         bm.RenderTarget[0].SrcBlend = bm.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_SRC_ALPHA;
>         bm.RenderTarget[0].DestBlend = bm.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_INV_SRC_ALPHA;
>         bm.RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
>         DIRECTX.Device->CreateBlendState(&bm, &BlendState);
>     }
547,548c591,593
<         Release(D3DVert);
<         Release(D3DPix);
---
>         Release(VertexShader);
>         Release(VertexShaderInstanced);
>         Release(PixelShader);
561,565c606,610
< 	XMFLOAT3  Pos;
< 	DWORD     C;
< 	float     U, V;
< 	Vertex() {};
< 	Vertex(XMFLOAT3 pos, DWORD c, float u, float v) : Pos(pos), C(c), U(u), V(v) {};
---
>     XMFLOAT3  Pos;
>     uint32_t  C;
>     float     U, V;
>     Vertex() {};
>     Vertex(XMFLOAT3 pos, uint32_t c, float u, float v) : Pos(pos), C(c), U(u), V(v) {};
571,579c616,624
< 	int       numVertices, numIndices, maxBuffer;
< 	Vertex    * Vertices;
< 	short     * Indices;
< 	TriangleSet(int maxTriangles = 2000) : maxBuffer(3 * maxTriangles)
< 	{
< 		numVertices = numIndices = 0;
< 		Vertices = (Vertex *)_aligned_malloc(maxBuffer *sizeof(Vertex), 16);
< 		Indices = (short *)  _aligned_malloc(maxBuffer *sizeof(short), 16);
< 	}
---
>     int       numVertices, numIndices, maxBuffer;
>     Vertex    * Vertices;
>     short     * Indices;
>     TriangleSet(int maxTriangles = 2000) : maxBuffer(3 * maxTriangles)
>     {
>         numVertices = numIndices = 0;
>         Vertices = (Vertex *)_aligned_malloc(maxBuffer *sizeof(Vertex), 16);
>         Indices = (short *)  _aligned_malloc(maxBuffer *sizeof(short), 16);
>     }
585,674c630,678
< 	void AddQuad(Vertex v0, Vertex v1, Vertex v2, Vertex v3) { AddTriangle(v0, v1, v2);	AddTriangle(v3, v2, v1); }
< 	void AddTriangle(Vertex v0, Vertex v1, Vertex v2)
< 	{
< 		VALIDATE(numVertices <= (maxBuffer - 3), "Insufficient triangle set");
< 		for (int i = 0; i < 3; i++) Indices[numIndices++] = numVertices + i;
< 		Vertices[numVertices++] = v0;
< 		Vertices[numVertices++] = v1;
< 		Vertices[numVertices++] = v2;
< 	}
< 
< 	DWORD ModifyColor(DWORD c, XMFLOAT3 pos)
< 	{
< 		#define GetLengthLocal(v)  (sqrt(v.x*v.x + v.y*v.y + v.z*v.z))
< 		float dist1 = GetLengthLocal(XMFLOAT3(pos.x - (-2), pos.y - (4), pos.z - (-2)));
< 		float dist2 = GetLengthLocal(XMFLOAT3(pos.x - (3),  pos.y - (4), pos.z - (-3)));
< 		float dist3 = GetLengthLocal(XMFLOAT3(pos.x - (-4), pos.y - (3), pos.z - (25)));
< 		int   bri = rand() % 160;
< 		float R = ((c >> 16) & 0xff) * (bri + 192.0f*(0.65f + 8 / dist1 + 1 / dist2 + 4 / dist3)) / 255.0f;
< 		float G = ((c >> 8) & 0xff) * (bri + 192.0f*(0.65f + 8 / dist1 + 1 / dist2 + 4 / dist3)) / 255.0f;
< 		float B = ((c >> 0) & 0xff) * (bri + 192.0f*(0.65f + 8 / dist1 + 1 / dist2 + 4 / dist3)) / 255.0f;
< 		return( (c & 0xff000000) + ((R>255 ? 255 : (DWORD)R) << 16) + ((G>255 ? 255 : (DWORD)G) << 8) + (B>255 ? 255 : (DWORD)B));
< 	}
< 
< 	void AddSolidColorBox(float x1, float y1, float z1, float x2, float y2, float z2, DWORD c)
< 	{
< 		AddQuad(Vertex(XMFLOAT3(x1, y2, z1), ModifyColor(c, XMFLOAT3(x1, y2, z1)), z1, x1),
< 			    Vertex(XMFLOAT3(x2, y2, z1), ModifyColor(c, XMFLOAT3(x2, y2, z1)), z1, x2),
< 			    Vertex(XMFLOAT3(x1, y2, z2), ModifyColor(c, XMFLOAT3(x1, y2, z2)), z2, x1),
< 			    Vertex(XMFLOAT3(x2, y2, z2), ModifyColor(c, XMFLOAT3(x2, y2, z2)), z2, x2));
< 		AddQuad(Vertex(XMFLOAT3(x2, y1, z1), ModifyColor(c, XMFLOAT3(x2, y1, z1)), z1, x2),
< 			    Vertex(XMFLOAT3(x1, y1, z1), ModifyColor(c, XMFLOAT3(x1, y1, z1)), z1, x1),
< 			    Vertex(XMFLOAT3(x2, y1, z2), ModifyColor(c, XMFLOAT3(x2, y1, z2)), z2, x2),
< 			    Vertex(XMFLOAT3(x1, y1, z2), ModifyColor(c, XMFLOAT3(x1, y1, z2)), z2, x1));
< 		AddQuad(Vertex(XMFLOAT3(x1, y1, z2), ModifyColor(c, XMFLOAT3(x1, y1, z2)), z2, y1),
< 			    Vertex(XMFLOAT3(x1, y1, z1), ModifyColor(c, XMFLOAT3(x1, y1, z1)), z1, y1),
< 			    Vertex(XMFLOAT3(x1, y2, z2), ModifyColor(c, XMFLOAT3(x1, y2, z2)), z2, y2),
< 			    Vertex(XMFLOAT3(x1, y2, z1), ModifyColor(c, XMFLOAT3(x1, y2, z1)), z1, y2));
< 		AddQuad(Vertex(XMFLOAT3(x2, y1, z1), ModifyColor(c, XMFLOAT3(x2, y1, z1)), z1, y1),
< 			    Vertex(XMFLOAT3(x2, y1, z2), ModifyColor(c, XMFLOAT3(x2, y1, z2)), z2, y1),
< 			    Vertex(XMFLOAT3(x2, y2, z1), ModifyColor(c, XMFLOAT3(x2, y2, z1)), z1, y2),
< 			    Vertex(XMFLOAT3(x2, y2, z2), ModifyColor(c, XMFLOAT3(x2, y2, z2)), z2, y2));
< 		AddQuad(Vertex(XMFLOAT3(x1, y1, z1), ModifyColor(c, XMFLOAT3(x1, y1, z1)), x1, y1),
< 			    Vertex(XMFLOAT3(x2, y1, z1), ModifyColor(c, XMFLOAT3(x2, y1, z1)), x2, y1),
< 			    Vertex(XMFLOAT3(x1, y2, z1), ModifyColor(c, XMFLOAT3(x1, y2, z1)), x1, y2),
< 			    Vertex(XMFLOAT3(x2, y2, z1), ModifyColor(c, XMFLOAT3(x2, y2, z1)), x2, y2));
< 		AddQuad(Vertex(XMFLOAT3(x2, y1, z2), ModifyColor(c, XMFLOAT3(x2, y1, z2)), x2, y1),
< 			    Vertex(XMFLOAT3(x1, y1, z2), ModifyColor(c, XMFLOAT3(x1, y1, z2)), x1, y1),
< 			    Vertex(XMFLOAT3(x2, y2, z2), ModifyColor(c, XMFLOAT3(x2, y2, z2)), x2, y2),
< 			    Vertex(XMFLOAT3(x1, y2, z2), ModifyColor(c, XMFLOAT3(x1, y2, z2)), x1, y2));
< 	}
< 
<     void AddMultiColorBox(float x1, float y1, float z1, float x2, float y2, float z2, DWORD c[6])
<     {
<         const struct {
<             XMFLOAT3 pos;
<             float u, v;
<         } Vert[] =
<         {
<             { XMFLOAT3(x1, y2, z1), z1, x1 },
<             { XMFLOAT3(x2, y2, z1), z1, x2 },
<             { XMFLOAT3(x1, y2, z2), z2, x1 },
<             { XMFLOAT3(x2, y2, z2), z2, x2 },
<             { XMFLOAT3(x2, y1, z1), z1, x2 },
<             { XMFLOAT3(x1, y1, z1), z1, x1 },
<             { XMFLOAT3(x2, y1, z2), z2, x2 },
<             { XMFLOAT3(x1, y1, z2), z2, x1 },
<             { XMFLOAT3(x1, y1, z2), z2, y1 },
<             { XMFLOAT3(x1, y1, z1), z1, y1 },
<             { XMFLOAT3(x1, y2, z2), z2, y2 },
<             { XMFLOAT3(x1, y2, z1), z1, y2 },
<             { XMFLOAT3(x2, y1, z1), z1, y1 },
<             { XMFLOAT3(x2, y1, z2), z2, y1 },
<             { XMFLOAT3(x2, y2, z1), z1, y2 },
<             { XMFLOAT3(x2, y2, z2), z2, y2 },
<             { XMFLOAT3(x1, y1, z1), x1, y1 },
<             { XMFLOAT3(x2, y1, z1), x2, y1 },
<             { XMFLOAT3(x1, y2, z1), x1, y2 },
<             { XMFLOAT3(x2, y2, z1), x2, y2 },
<             { XMFLOAT3(x2, y1, z2), x2, y1 },
<             { XMFLOAT3(x1, y1, z2), x1, y1 },
<             { XMFLOAT3(x2, y2, z2), x2, y2 },
<             { XMFLOAT3(x1, y2, z2), x1, y2 },
<         };
<         for (int v = 0; v < 24; v += 4)
<         {
<             AddQuad(Vertex(Vert[v + 0].pos, c[v / 4], Vert[v + 0].u, Vert[v + 0].v),
<                     Vertex(Vert[v + 1].pos, c[v / 4], Vert[v + 1].u, Vert[v + 1].v),
<                     Vertex(Vert[v + 2].pos, c[v / 4], Vert[v + 2].u, Vert[v + 2].v),
<                     Vertex(Vert[v + 3].pos, c[v / 4], Vert[v + 3].u, Vert[v + 3].v));
<         }
---
>     void AddQuad(Vertex v0, Vertex v1, Vertex v2, Vertex v3) { AddTriangle(v0, v1, v2);	AddTriangle(v3, v2, v1); }
>     void AddTriangle(Vertex v0, Vertex v1, Vertex v2)
>     {
>         VALIDATE(numVertices <= (maxBuffer - 3), "Insufficient triangle set");
>         for (int i = 0; i < 3; i++) Indices[numIndices++] = numVertices + i;
>         Vertices[numVertices++] = v0;
>         Vertices[numVertices++] = v1;
>         Vertices[numVertices++] = v2;
>     }
> 
>     uint32_t ModifyColor(uint32_t c, XMFLOAT3 pos)
>     {
>         #define GetLengthLocal(v)  (sqrt(v.x*v.x + v.y*v.y + v.z*v.z))
>         float dist1 = GetLengthLocal(XMFLOAT3(pos.x - (-2), pos.y - (4), pos.z - (-2)));
>         float dist2 = GetLengthLocal(XMFLOAT3(pos.x - (3),  pos.y - (4), pos.z - (-3)));
>         float dist3 = GetLengthLocal(XMFLOAT3(pos.x - (-4), pos.y - (3), pos.z - (25)));
>         int   bri = rand() % 160;
>         float R = ((c >> 16) & 0xff) * (bri + 192.0f*(0.65f + 8 / dist1 + 1 / dist2 + 4 / dist3)) / 255.0f;
>         float G = ((c >> 8) & 0xff) * (bri + 192.0f*(0.65f + 8 / dist1 + 1 / dist2 + 4 / dist3)) / 255.0f;
>         float B = ((c >> 0) & 0xff) * (bri + 192.0f*(0.65f + 8 / dist1 + 1 / dist2 + 4 / dist3)) / 255.0f;
>         return( (c & 0xff000000) + ((R>255 ? 255 : (uint32_t)R) << 16) + ((G>255 ? 255 : (uint32_t)G) << 8) + (B>255 ? 255 : (uint32_t)B));
>     }
> 
>     void AddSolidColorBox(float x1, float y1, float z1, float x2, float y2, float z2, uint32_t c)
>     {
>         AddQuad(Vertex(XMFLOAT3(x1, y2, z1), ModifyColor(c, XMFLOAT3(x1, y2, z1)), z1, x1),
>                 Vertex(XMFLOAT3(x2, y2, z1), ModifyColor(c, XMFLOAT3(x2, y2, z1)), z1, x2),
>                 Vertex(XMFLOAT3(x1, y2, z2), ModifyColor(c, XMFLOAT3(x1, y2, z2)), z2, x1),
>                 Vertex(XMFLOAT3(x2, y2, z2), ModifyColor(c, XMFLOAT3(x2, y2, z2)), z2, x2));
>         AddQuad(Vertex(XMFLOAT3(x2, y1, z1), ModifyColor(c, XMFLOAT3(x2, y1, z1)), z1, x2),
>                 Vertex(XMFLOAT3(x1, y1, z1), ModifyColor(c, XMFLOAT3(x1, y1, z1)), z1, x1),
>                 Vertex(XMFLOAT3(x2, y1, z2), ModifyColor(c, XMFLOAT3(x2, y1, z2)), z2, x2),
>                 Vertex(XMFLOAT3(x1, y1, z2), ModifyColor(c, XMFLOAT3(x1, y1, z2)), z2, x1));
>         AddQuad(Vertex(XMFLOAT3(x1, y1, z2), ModifyColor(c, XMFLOAT3(x1, y1, z2)), z2, y1),
>                 Vertex(XMFLOAT3(x1, y1, z1), ModifyColor(c, XMFLOAT3(x1, y1, z1)), z1, y1),
>                 Vertex(XMFLOAT3(x1, y2, z2), ModifyColor(c, XMFLOAT3(x1, y2, z2)), z2, y2),
>                 Vertex(XMFLOAT3(x1, y2, z1), ModifyColor(c, XMFLOAT3(x1, y2, z1)), z1, y2));
>         AddQuad(Vertex(XMFLOAT3(x2, y1, z1), ModifyColor(c, XMFLOAT3(x2, y1, z1)), z1, y1),
>                 Vertex(XMFLOAT3(x2, y1, z2), ModifyColor(c, XMFLOAT3(x2, y1, z2)), z2, y1),
>                 Vertex(XMFLOAT3(x2, y2, z1), ModifyColor(c, XMFLOAT3(x2, y2, z1)), z1, y2),
>                 Vertex(XMFLOAT3(x2, y2, z2), ModifyColor(c, XMFLOAT3(x2, y2, z2)), z2, y2));
>         AddQuad(Vertex(XMFLOAT3(x1, y1, z1), ModifyColor(c, XMFLOAT3(x1, y1, z1)), x1, y1),
>                 Vertex(XMFLOAT3(x2, y1, z1), ModifyColor(c, XMFLOAT3(x2, y1, z1)), x2, y1),
>                 Vertex(XMFLOAT3(x1, y2, z1), ModifyColor(c, XMFLOAT3(x1, y2, z1)), x1, y2),
>                 Vertex(XMFLOAT3(x2, y2, z1), ModifyColor(c, XMFLOAT3(x2, y2, z1)), x2, y2));
>         AddQuad(Vertex(XMFLOAT3(x2, y1, z2), ModifyColor(c, XMFLOAT3(x2, y1, z2)), x2, y1),
>                 Vertex(XMFLOAT3(x1, y1, z2), ModifyColor(c, XMFLOAT3(x1, y1, z2)), x1, y1),
>                 Vertex(XMFLOAT3(x2, y2, z2), ModifyColor(c, XMFLOAT3(x2, y2, z2)), x2, y2),
>                 Vertex(XMFLOAT3(x1, y2, z2), ModifyColor(c, XMFLOAT3(x1, y2, z2)), x1, y2));
681,686c685,690
< 	XMFLOAT3     Pos; 
< 	XMFLOAT4     Rot; 
< 	Material   * Fill;
< 	DataBuffer * VertexBuffer;
< 	DataBuffer * IndexBuffer;
< 	int          NumIndices;
---
>     XMFLOAT3     Pos; 
>     XMFLOAT4     Rot; 
>     Material   * Fill;
>     DataBuffer * VertexBuffer;
>     DataBuffer * IndexBuffer;
>     int          NumIndices;
688c692
< 	Model() : Fill(nullptr), VertexBuffer(nullptr), IndexBuffer(nullptr) {};
---
>     Model() : Fill(nullptr), VertexBuffer(nullptr), IndexBuffer(nullptr) {};
691,693c695,697
< 		NumIndices = t->numIndices;
< 		VertexBuffer = new DataBuffer(DIRECTX.Device, D3D11_BIND_VERTEX_BUFFER, &t->Vertices[0], t->numVertices * sizeof(Vertex));
< 		IndexBuffer = new DataBuffer(DIRECTX.Device, D3D11_BIND_INDEX_BUFFER, &t->Indices[0], t->numIndices * sizeof(short));
---
>         NumIndices = t->numIndices;
>         VertexBuffer = new DataBuffer(DIRECTX.Device, D3D11_BIND_VERTEX_BUFFER, &t->Vertices[0], t->numVertices * sizeof(Vertex));
>         IndexBuffer = new DataBuffer(DIRECTX.Device, D3D11_BIND_INDEX_BUFFER, &t->Indices[0], t->numIndices * sizeof(short));
695c699
< 	Model(TriangleSet * t, XMFLOAT3 argPos, XMFLOAT4 argRot, Material * argFill) :
---
>     Model(TriangleSet * t, XMFLOAT3 argPos, XMFLOAT4 argRot, Material * argFill) :
699c703
< 	{
---
>     {
701c705
< 	}
---
>     }
703c707
< 	Model(Material * mat, float minx, float miny, float maxx, float maxy,  float zDepth = 0) :
---
>     Model(Material * mat, float minx, float miny, float maxx, float maxy,  float zDepth = 0) :
707,712c711,716
< 	{
< 		TriangleSet quad;
< 		quad.AddQuad(Vertex(XMFLOAT3(minx, miny, zDepth), 0xffffffff, 0, 1),
< 			Vertex(XMFLOAT3(minx, maxy, zDepth), 0xffffffff, 0, 0),
< 			Vertex(XMFLOAT3(maxx, miny, zDepth), 0xffffffff, 1, 1),
< 			Vertex(XMFLOAT3(maxx, maxy, zDepth), 0xffffffff, 1, 0));
---
>     {
>         TriangleSet quad;
>         quad.AddQuad(Vertex(XMFLOAT3(minx, miny, zDepth), 0xffffffff, 0, 1),
>             Vertex(XMFLOAT3(minx, maxy, zDepth), 0xffffffff, 0, 0),
>             Vertex(XMFLOAT3(maxx, miny, zDepth), 0xffffffff, 1, 1),
>             Vertex(XMFLOAT3(maxx, maxy, zDepth), 0xffffffff, 1, 0));
714c718
< 	}
---
>     }
722,746c726,785
< 	void Render(XMMATRIX * projView, float R, float G, float B, float A, bool standardUniforms)
< 	{
< 		XMMATRIX modelMat = XMMatrixMultiply(XMMatrixRotationQuaternion(XMLoadFloat4(&Rot)), XMMatrixTranslationFromVector(XMLoadFloat3(&Pos)));
< 		XMMATRIX mat = XMMatrixMultiply(modelMat, *projView);
< 		float col[] = { R, G, B, A };
< 		if (standardUniforms) memcpy(DIRECTX.UniformData + 0, &mat, 64); // ProjView
< 		if (standardUniforms) memcpy(DIRECTX.UniformData + 64, &col, 16); // MasterCol
< 		D3D11_MAPPED_SUBRESOURCE map;
< 		DIRECTX.Context->Map(DIRECTX.UniformBufferGen->D3DBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &map);
< 		memcpy(map.pData, &DIRECTX.UniformData, DIRECTX.UNIFORM_DATA_SIZE);
< 		DIRECTX.Context->Unmap(DIRECTX.UniformBufferGen->D3DBuffer, 0);
< 		DIRECTX.Context->IASetInputLayout(Fill->InputLayout);
< 		DIRECTX.Context->IASetIndexBuffer(IndexBuffer->D3DBuffer, DXGI_FORMAT_R16_UINT, 0);
< 		UINT offset = 0;
< 		DIRECTX.Context->IASetVertexBuffers(0, 1, &VertexBuffer->D3DBuffer, &Fill->VertexSize, &offset);
< 		DIRECTX.Context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
< 		DIRECTX.Context->VSSetShader(Fill->D3DVert, NULL, 0);
< 		DIRECTX.Context->PSSetShader(Fill->D3DPix, NULL, 0);
< 		DIRECTX.Context->PSSetSamplers(0, 1, &Fill->SamplerState);
< 		DIRECTX.Context->RSSetState(Fill->Rasterizer);
< 		DIRECTX.Context->OMSetDepthStencilState(Fill->DepthState, 0);
< 		DIRECTX.Context->OMSetBlendState(Fill->BlendState, NULL, 0xffffffff);
< 		DIRECTX.Context->PSSetShaderResources(0, 1, &Fill->Tex->TexSv);
< 		DIRECTX.Context->DrawIndexed((UINT)NumIndices, 0, 0);
< 	}
---
>     void Render(XMMATRIX * projView, float R, float G, float B, float A, bool standardUniforms)
>     {
>         XMMATRIX modelMat = XMMatrixMultiply(XMMatrixRotationQuaternion(XMLoadFloat4(&Rot)), XMMatrixTranslationFromVector(XMLoadFloat3(&Pos)));
>         XMMATRIX mat = XMMatrixMultiply(modelMat, *projView);
>         float col[] = { R, G, B, A };
>         if (standardUniforms) memcpy(DIRECTX.UniformData + 0, &mat, 64); // ProjView
>         if (standardUniforms) memcpy(DIRECTX.UniformData + 64, &col, 16); // MasterCol
>         D3D11_MAPPED_SUBRESOURCE map;
>         DIRECTX.Context->Map(DIRECTX.UniformBufferGen->D3DBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &map);
>         memcpy(map.pData, &DIRECTX.UniformData, DIRECTX.UNIFORM_DATA_SIZE);
>         DIRECTX.Context->Unmap(DIRECTX.UniformBufferGen->D3DBuffer, 0);
>         DIRECTX.Context->IASetInputLayout(Fill->InputLayout);
>         DIRECTX.Context->IASetIndexBuffer(IndexBuffer->D3DBuffer, DXGI_FORMAT_R16_UINT, 0);
>         UINT offset = 0;
>         DIRECTX.Context->IASetVertexBuffers(0, 1, &VertexBuffer->D3DBuffer, &Fill->VertexSize, &offset);
>         DIRECTX.Context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
>         DIRECTX.Context->VSSetShader(Fill->VertexShader, NULL, 0);
>         DIRECTX.Context->PSSetShader(Fill->PixelShader, NULL, 0);
>         DIRECTX.Context->PSSetSamplers(0, 1, &Fill->SamplerState);
>         DIRECTX.Context->RSSetState(Fill->Rasterizer);
>         DIRECTX.Context->OMSetDepthStencilState(Fill->DepthState, 0);
>         DIRECTX.Context->OMSetBlendState(Fill->BlendState, NULL, 0xffffffff);
>         DIRECTX.Context->PSSetShaderResources(0, 1, &Fill->Tex->TexSv);
> 
>         DIRECTX.Context->DrawIndexed((UINT)NumIndices, 0, 0);
>     }
> 
>     // render using stereo instancing
>     void RenderInstanced(XMMATRIX *viewProjMats, float R, float G, float B, float A, bool standardUniforms)
>     {
>         XMMATRIX modelMat = XMMatrixMultiply(XMMatrixRotationQuaternion(XMLoadFloat4(&Rot)), XMMatrixTranslationFromVector(XMLoadFloat3(&Pos)));
>         XMMATRIX modelViewProjMatL = XMMatrixMultiply(modelMat, viewProjMats[0]);
>         XMMATRIX modelViewProjMatR = XMMatrixMultiply(modelMat, viewProjMats[1]);
>         float col[] = { R, G, B, A };
>         if (standardUniforms) {
>             memcpy(DIRECTX.UniformData + 0, &modelViewProjMatL, 64);
>             memcpy(DIRECTX.UniformData + 64, &modelViewProjMatR, 64);
>             memcpy(DIRECTX.UniformData + 128, &col, 16); // MasterCol
>         }
>         D3D11_MAPPED_SUBRESOURCE map;
>         DIRECTX.Context->Map(DIRECTX.UniformBufferGen->D3DBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &map);
>         memcpy(map.pData, &DIRECTX.UniformData, DIRECTX.UNIFORM_DATA_SIZE);
>         DIRECTX.Context->Unmap(DIRECTX.UniformBufferGen->D3DBuffer, 0);
>         DIRECTX.Context->IASetInputLayout(Fill->InputLayout);
>         DIRECTX.Context->IASetIndexBuffer(IndexBuffer->D3DBuffer, DXGI_FORMAT_R16_UINT, 0);
>         UINT offset = 0;
>         DIRECTX.Context->IASetVertexBuffers(0, 1, &VertexBuffer->D3DBuffer, &Fill->VertexSize, &offset);
>         DIRECTX.Context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
>         DIRECTX.Context->VSSetShader(Fill->VertexShaderInstanced, NULL, 0);
>         DIRECTX.Context->PSSetShader(Fill->PixelShader, NULL, 0);
>         DIRECTX.Context->PSSetSamplers(0, 1, &Fill->SamplerState);
>         DIRECTX.Context->RSSetState(Fill->Rasterizer);
>         DIRECTX.Context->OMSetDepthStencilState(Fill->DepthState, 0);
>         DIRECTX.Context->OMSetBlendState(Fill->BlendState, NULL, 0xffffffff);
>         DIRECTX.Context->PSSetShaderResources(0, 1, &Fill->Tex->TexSv);
> 
>         // draw 2 instances
>         DIRECTX.Context->DrawIndexedInstanced((UINT)NumIndices, 2, 0, 0, 0);
>     }
> 
753c792
< 	Model *Models[MAX_MODELS];
---
>     Model *Models[MAX_MODELS];
756c795
< 	void Add(Model * n)
---
>     void Add(Model * n)
762,764c801,803
< 	void Render(XMMATRIX * projView, float R, float G, float B, float A, bool standardUniforms)
< 	{
< 		for (int i = 0; i < numModels; ++i)
---
>     void Render(XMMATRIX * projView, float R, float G, float B, float A, bool standardUniforms)
>     {
>         for (int i = 0; i < numModels; ++i)
766,767c805,812
< 	}
<     
---
>     }
> 
>     void RenderInstanced(XMMATRIX * projViews, float R, float G, float B, float A, bool standardUniforms)
>     {
>         for (int i = 0; i < numModels; ++i)
>             Models[i]->RenderInstanced(projViews, R, G, B, A, standardUniforms);
>     }
> 
769,770c814
< 	{
<         // Moving box
---
>     {
772,776c816
<         DWORD boxColors[6] = {
<             CMYK(0xff, 150, 64, 64),  CMYK(0xff, 64, 150, 64),  CMYK(0xff, 64, 64, 150),
<             CMYK(0xff, 150, 64, 150), CMYK(0xff, 150, 150, 64), CMYK(0xff, 64, 150, 150)
<         };
<         cube.AddMultiColorBox(0, 0, 0, +1.0f, +1.0f, 1.0f, boxColors);
---
>         cube.AddSolidColorBox(0.5f, -0.5f, 0.5f, -0.5f, 0.5f, -0.5f, 0xff404040);
780,807c820
<                     new Texture(false, 256, 256, Texture::AUTO_WHITE)
<                     )
<                 )
<             );
< 
<         // Hammer
<         TriangleSet hammer;
<         DWORD box2Colors[6] = {
<             CMYK(0xff, 40, 32, 32), CMYK(0xff, 40, 32, 32), CMYK(0xff, 40, 32, 32),
<             CMYK(0xff, 40, 32, 32), CMYK(0xff, 40, 32, 32), CMYK(0xff, 40, 32, 32)
<         };
<         hammer.AddMultiColorBox(0, 0, 0, +1.0f, +4.0f, 1.0f, box2Colors);
<         Add(
<             new Model(&hammer, XMFLOAT3(0, 0, 0), XMFLOAT4(0, 0, 0, 1),
<                 new Material(
<                     new Texture(false, 256, 256, Texture::AUTO_WHITE)
<                     )
<                 )
<             );
< 
<         // Anvil
<         TriangleSet anvil;
<         anvil.AddMultiColorBox(0, -3.0, 0, +1.0f, +1.0f, 1.0f, box2Colors);
<         Add(
<             new Model(&anvil, XMFLOAT3(0, 0, 0), XMFLOAT4(0, 0, 0, 1),
<                 new Material(
<                     new Texture(false, 256, 256, Texture::AUTO_WHITE)
<                     )
---
>                     new Texture(false, 256, 256, Texture::AUTO_CEILING)
809c822,823
<             );
---
>             )
>         );
811,814c825,826
<         // Radio
<         TriangleSet radio;
<         radio.AddSolidColorBox(0.0, 0.0, 0.0, .33f, .54f, .87f, CMYK(0xff, 80, 32, 32));  // Left Wall
<         radio.AddSolidColorBox(0.05f, 0.05f, 0.05f, .34f, .49f, .82f, CMYK(0xff, 80, 80, 60)); // Back Wall
---
>         TriangleSet spareCube;
>         spareCube.AddSolidColorBox(0.1f, -0.1f, 0.1f, -0.1f, +0.1f, -0.1f, 0xffff0000);
816,825d827
<             new Model(&radio, XMFLOAT3(0, 0, 0), XMFLOAT4(0, 0, 0, 1),
<                 new Material(
<                     new Texture(false, 256, 256, Texture::AUTO_WHITE)
<                     )
<                 )
<             );
< 
< 		TriangleSet spareCube;
< 		spareCube.AddSolidColorBox(0.1f, -0.1f, 0.1f, -0.1f, +0.1f, -0.1f, 0xffff0000);
< 		Add(
833,837c835,839
< 		TriangleSet walls;
< 		walls.AddSolidColorBox(10.1f, 0.0f, 20.0f, 10.0f, 4.0f, -20.0f, 0xff808080);  // Left Wall
< 		walls.AddSolidColorBox(10.0f, -0.1f, 20.1f, -10.0f, 4.0f, 20.0f, 0xff808080); // Back Wall
< 		walls.AddSolidColorBox(-10.0f, -0.1f, 20.0f, -10.1f, 4.0f, -20.0f, 0xff808080);   // Right Wall
< 		Add(
---
>         TriangleSet walls;
>         walls.AddSolidColorBox(10.1f, 0.0f, 20.0f, 10.0f, 4.0f, -20.0f, 0xff808080);  // Left Wall
>         walls.AddSolidColorBox(10.0f, -0.1f, 20.1f, -10.0f, 4.0f, 20.0f, 0xff808080); // Back Wall
>         walls.AddSolidColorBox(-10.0f, -0.1f, 20.0f, -10.1f, 4.0f, -20.0f, 0xff808080);   // Right Wall
>         Add(
845,850c847,852
< 		if (includeIntensiveGPUobject)
< 		{
< 			TriangleSet partitions;
< 			for (float depth = 0.0f; depth > -3.0f; depth -= 0.1f)
< 				partitions.AddSolidColorBox(9.0f, 0.5f, -depth, -9.0f, 3.5f, -depth, 0x10ff80ff); // Partition
< 			Add(
---
>         if (includeIntensiveGPUobject)
>         {
>             TriangleSet partitions;
>             for (float depth = 0.0f; depth > -3.0f; depth -= 0.1f)
>                 partitions.AddSolidColorBox(9.0f, 0.5f, -depth, -9.0f, 3.5f, -depth, 0x10ff80ff); // Partition
>             Add(
857c859
< 		}
---
>         }
859,862c861,864
< 		TriangleSet floors;
< 		floors.AddSolidColorBox(10.0f, -0.1f, 20.0f, -10.0f, 0.0f, -20.1f, 0xff808080); // Main floor
< 		floors.AddSolidColorBox(15.0f, -6.1f, -18.0f, -15.0f, -6.0f, -30.0f, 0xff808080); // Bottom floor
< 		Add(
---
>         TriangleSet floors;
>         floors.AddSolidColorBox(10.0f, -0.1f, 20.0f, -10.0f, 0.0f, -20.1f, 0xff808080); // Main floor
>         floors.AddSolidColorBox(15.0f, -6.1f, -18.0f, -15.0f, -6.0f, -30.0f, 0xff808080); // Bottom floor
>         Add(
870,872c872,874
< 		TriangleSet ceiling;
< 		ceiling.AddSolidColorBox(10.0f, 4.0f, 20.0f, -10.0f, 4.1f, -20.1f, 0xff808080);
< 		Add(
---
>         TriangleSet ceiling;
>         ceiling.AddSolidColorBox(10.0f, 4.0f, 20.0f, -10.0f, 4.1f, -20.1f, 0xff808080);
>         Add(
880,887c882,889
< 		TriangleSet furniture;
< 		furniture.AddSolidColorBox(-9.5f, 0.75f, -3.0f, -10.1f, 2.5f, -3.1f, 0xff383838);    // Right side shelf// Verticals
< 		furniture.AddSolidColorBox(-9.5f, 0.95f, -3.7f, -10.1f, 2.75f, -3.8f, 0xff383838);   // Right side shelf
< 		furniture.AddSolidColorBox(-9.55f, 1.20f, -2.5f, -10.1f, 1.30f, -3.75f, 0xff383838); // Right side shelf// Horizontals
< 		furniture.AddSolidColorBox(-9.55f, 2.00f, -3.05f, -10.1f, 2.10f, -4.2f, 0xff383838); // Right side shelf
< 		furniture.AddSolidColorBox(-5.0f, 1.1f, -20.0f, -10.0f, 1.2f, -20.1f, 0xff383838);   // Right railing   
< 		furniture.AddSolidColorBox(10.0f, 1.1f, -20.0f, 5.0f, 1.2f, -20.1f, 0xff383838);   // Left railing  
< 		for (float f = 5; f <= 9; f += 1)
---
>         TriangleSet furniture;
>         furniture.AddSolidColorBox(-9.5f, 0.75f, -3.0f, -10.1f, 2.5f, -3.1f, 0xff383838);    // Right side shelf// Verticals
>         furniture.AddSolidColorBox(-9.5f, 0.95f, -3.7f, -10.1f, 2.75f, -3.8f, 0xff383838);   // Right side shelf
>         furniture.AddSolidColorBox(-9.55f, 1.20f, -2.5f, -10.1f, 1.30f, -3.75f, 0xff383838); // Right side shelf// Horizontals
>         furniture.AddSolidColorBox(-9.55f, 2.00f, -3.05f, -10.1f, 2.10f, -4.2f, 0xff383838); // Right side shelf
>         furniture.AddSolidColorBox(-5.0f, 1.1f, -20.0f, -10.0f, 1.2f, -20.1f, 0xff383838);   // Right railing   
>         furniture.AddSolidColorBox(10.0f, 1.1f, -20.0f, 5.0f, 1.2f, -20.1f, 0xff383838);   // Left railing  
>         for (float f = 5; f <= 9; f += 1)
889c891
< 		for (float f = 5; f <= 9; f += 1)
---
>         for (float f = 5; f <= 9; f += 1)
891,902c893,904
< 		furniture.AddSolidColorBox(-1.8f, 0.8f, 1.0f, 0.0f, 0.7f, 0.0f, 0xff505000);  // Table
< 		furniture.AddSolidColorBox(-1.8f, 0.0f, 0.0f, -1.7f, 0.7f, 0.1f, 0xff505000); // Table Leg 
< 		furniture.AddSolidColorBox(-1.8f, 0.7f, 1.0f, -1.7f, 0.0f, 0.9f, 0xff505000); // Table Leg 
< 		furniture.AddSolidColorBox(0.0f, 0.0f,  1.0f, -0.1f, 0.7f, 0.9f, 0xff505000);  // Table Leg 
< 		furniture.AddSolidColorBox(0.0f, 0.7f, 0.0f, -0.1f, 0.0f,-0.1f, 0xff505000);  // Table Leg 
< 		furniture.AddSolidColorBox(-1.4f, 0.5f, -1.1f, -0.8f, 0.55f, -0.5f, 0xff202050);  // Chair Set
< 		furniture.AddSolidColorBox(-1.401f, 0.0f, -1.101f, -1.339f, 1.0f, -1.039f, 0xff202050); // Chair Leg 1
< 		furniture.AddSolidColorBox(-1.401f, 0.5f, -0.499f, -1.339f, 0.0f, -0.561f, 0xff202050); // Chair Leg 2
< 		furniture.AddSolidColorBox(-0.799f, 0.0f, -0.499f, -0.861f, 0.5f, -0.561f, 0xff202050); // Chair Leg 2
< 		furniture.AddSolidColorBox(-0.799f, 1.0f, -1.101f, -0.861f, 0.0f, -1.039f, 0xff202050); // Chair Leg 2
< 		furniture.AddSolidColorBox(-1.4f, 0.97f, -1.05f, -0.8f, 0.92f, -1.10f, 0xff202050); // Chair Back high bar
< 		for (float f = 3.0f; f <= 6.6f; f += 0.4f)
---
>         furniture.AddSolidColorBox(1.8f, 0.8f, -1.0f, 0.0f, 0.7f, 0.0f, 0xff505000);  // Table
>         furniture.AddSolidColorBox(1.8f, 0.0f, 0.0f, 1.7f, 0.7f, -0.1f, 0xff505000); // Table Leg 
>         furniture.AddSolidColorBox(1.8f, 0.7f, -1.0f, 1.7f, 0.0f, -0.9f, 0xff505000); // Table Leg 
>         furniture.AddSolidColorBox(0.0f, 0.0f, -1.0f, 0.1f, 0.7f, -0.9f, 0xff505000);  // Table Leg 
>         furniture.AddSolidColorBox(0.0f, 0.7f, 0.0f, 0.1f, 0.0f, -0.1f, 0xff505000);  // Table Leg 
>         furniture.AddSolidColorBox(1.4f, 0.5f, 1.1f, 0.8f, 0.55f, 0.5f, 0xff202050);  // Chair Set
>         furniture.AddSolidColorBox(1.401f, 0.0f, 1.101f, 1.339f, 1.0f, 1.039f, 0xff202050); // Chair Leg 1
>         furniture.AddSolidColorBox(1.401f, 0.5f, 0.499f, 1.339f, 0.0f, 0.561f, 0xff202050); // Chair Leg 2
>         furniture.AddSolidColorBox(0.799f, 0.0f, 0.499f, 0.861f, 0.5f, 0.561f, 0xff202050); // Chair Leg 2
>         furniture.AddSolidColorBox(0.799f, 1.0f, 1.101f, 0.861f, 0.0f, 1.039f, 0xff202050); // Chair Leg 2
>         furniture.AddSolidColorBox(1.4f, 0.97f, 1.05f, 0.8f, 0.92f, 1.10f, 0xff202050); // Chair Back high bar
>         for (float f = 3.0f; f <= 6.6f; f += 0.4f)
904c906
< 		Add(
---
>         Add(
911c913
< 	}
---
>     }
913,914c915,916
< 	Scene() : numModels(0) {}
< 	Scene(bool includeIntensiveGPUobject) :
---
>     Scene() : numModels(0) {}
>     Scene(bool includeIntensiveGPUobject) :
933,941c935,953
< 	XMVECTOR Pos;
< 	XMVECTOR Rot;
< 	Camera() {};
< 	Camera(XMVECTOR * pos, XMVECTOR * rot) : Pos(*pos), Rot(*rot)	{};
< 	XMMATRIX GetViewMatrix()
< 	{
< 		XMVECTOR forward = XMVector3Rotate(XMVectorSet(0, 0, -1, 0), Rot);
< 		return(XMMatrixLookAtRH(Pos, XMVectorAdd(Pos, forward), XMVector3Rotate(XMVectorSet(0, 1, 0, 0), Rot)));
< 	}
---
>     XMVECTOR Pos;
>     XMVECTOR Rot;
>     Camera() {};
>     Camera(XMVECTOR * pos, XMVECTOR * rot) : Pos(*pos), Rot(*rot)	{};
>     XMMATRIX GetViewMatrix()
>     {
>         XMVECTOR forward = XMVector3Rotate(XMVectorSet(0, 0, -1, 0), Rot);
>         return(XMMatrixLookAtRH(Pos, XMVectorAdd(Pos, forward), XMVector3Rotate(XMVectorSet(0, 1, 0, 0), Rot)));
>     }
> 
>     static void* operator new(std::size_t size)
>     {
>         return _aligned_malloc(sizeof(Camera), __alignof(Camera));
>     }
> 
>     static void operator delete(void* p)
>     {
>         _aligned_free(p);
>     }
947,954c959,966
< 	void Output(const char * fnt, ...)
< 	{
< 		static char string_text[1000];
< 		va_list args; va_start(args, fnt);
< 		vsprintf_s(string_text, fnt, args);
< 		va_end(args);
< 		OutputDebugStringA(string_text);
< 	}
---
>     void Output(const char * fnt, ...)
>     {
>         static char string_text[1000];
>         va_list args; va_start(args, fnt);
>         vsprintf_s(string_text, fnt, args);
>         va_end(args);
>         OutputDebugStringA(string_text);
>     }
960,1002d971
< 
< 
< 
< /*
< 
< 	//Done with other file loading, lets open file for output.
< 	SYSTEMTIME syst;
< 	GetSystemTime(&syst);
< 	FILE * reportFile;
< 	char fileName[100];
< 	sprintf_s(fileName,100,"report_Date(%02d_%02d_%04d)_Time(%02d_%02d_%02d).txt",syst.wMonth,syst.wDay,syst.wYear,syst.wHour,syst.wMinute,syst.wSecond);
< 	fopen_s(&reportFile, File.Path(fileName), "wt");
< 
< 	//....and lets also open Parse
< 	ParseRecord t;
< 	t.OpenRecord(L"ugO4eVcwGiZHMvk7334Me73pY8FOLY67GBgejoMn", L"sfEZ2E3Uf8bbdkEcvovjdQjTdOYaXPxMvISnWDEZ", L"Report");
< 
< 	//And write the first data into both
< 	fprintf(reportFile,"----Comfort testing report file----     (View with Wordwrap off)\n\n");
< 	fprintf(reportFile,"Code version    = %s\n",ComfortTestingCodeVersion);
< 	fprintf(reportFile,"Headset         = %s\n",basicVR.HMD->ProductName);
< 	fprintf(reportFile,"Serial number   = %s\n",basicVR.HMD->SerialNumber);
< 	fprintf(reportFile,"Firmware        = %d.%d\n",basicVR.HMD->FirmwareMajor,basicVR.HMD->FirmwareMinor);
< 	fprintf(reportFile,"Manufacturer    = %s\n",basicVR.HMD->Manufacturer);
< 	fprintf(reportFile,"Resolution      = %d x %d\n",basicVR.HMD->Resolution.w,basicVR.HMD->Resolution.h);
< 	fprintf(reportFile,"Date(US format) = %02d/%02d/%04d\n",syst.wMonth,syst.wDay,syst.wYear);
< 	fprintf(reportFile,"Time            = %02d:%02d:%02d\n",syst.wHour,syst.wMinute,syst.wSecond);
< 	fprintf(reportFile,"User            = %s\n",ovr_GetString(basicVR.HMD, OVR_KEY_USER, "Unknown"));
< 	fprintf(reportFile,"Name            = %s\n",ovr_GetString(basicVR.HMD, OVR_KEY_NAME, "Unknown"));
< 	fprintf(reportFile,"Gender          = %s\n",ovr_GetString(basicVR.HMD, OVR_KEY_GENDER, "Unknown"));
< 	fprintf(reportFile,"Player height   = %f metres\n",ovr_GetFloat(basicVR.HMD, OVR_KEY_PLAYER_HEIGHT, -1));
< 	fprintf(reportFile,"Eye height      = %f metres\n",ovr_GetFloat(basicVR.HMD, OVR_KEY_EYE_HEIGHT, -1));
< 	fprintf(reportFile,"IPD             = %f metres\n",ovr_GetFloat(basicVR.HMD, OVR_KEY_IPD, -1));
< 	fprintf(reportFile,"Eye relief dial = %d\n",ovr_GetInt(basicVR.HMD, OVR_KEY_EYE_RELIEF_DIAL, -1));
< 
< 	t.AddData("Code version", ComfortTestingCodeVersion);
< //	t.AddData("Headset",      "%s",basicVR.HMD->ProductName);
< //	t.AddData("Serial number","%s",basicVR.HMD->SerialNumber);
< 
< 	t.SendData();
< 
< 
< */
\ No newline at end of file
