// CLKernelPreprocessor.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <string>
#include <fstream>
#include <vector>

#define MAX_SIZE_STRING  16384
#define MAX_BLOCK_CHUNK  12000

std::wstring getFileNameWithoutExtension(std::wstring& filepath)
{
	char sep = '/';
	char dot = '.';
#ifdef _WIN32
	sep = '\\';
#endif
	size_t seppos = filepath.rfind(sep, filepath.length());
	size_t dotpos = filepath.rfind(dot, filepath.length());
	if (dotpos > seppos && (dotpos != std::string::npos))
	{
		return(filepath.substr((seppos + 1), dotpos - seppos - 1));
	}
	if (seppos == std::wstring::npos)
	{
		return(filepath.substr(0, dotpos));
	}
	return filepath;
}

int _tmain(int argc, _TCHAR* argv[])
{
	std::wstring prefix = L"CLKernel";
	if (argc > 3)
	{
		printf("Too many paramters\n");
		return 1;
	}
	if (argc <= 1)
	{
		printf("Not enough parameters\n");
		return 1;
	}

	_TCHAR* clKernelFileFullName = argv[1];
	size_t clKernelFileNameLength = wcslen(clKernelFileFullName);
	_TCHAR* clKernelFileExt = clKernelFileFullName + (clKernelFileNameLength - 3);
	
	
	if (!wcscmp(clKernelFileExt, L".cl") || !wcscmp(clKernelFileExt, L".CL"))
	{
		errno_t WINError;
		std::wstring clKernelFileNameWSTR = getFileNameWithoutExtension(std::wstring(clKernelFileFullName));
		std::ifstream clKernelSS(clKernelFileFullName);
		std::wstring clKernlSource((std::istreambuf_iterator<char>(clKernelSS)),
			std::istreambuf_iterator<char>());
		std::wstring outputFileFullName;
		if (argc > 2)
		{
			outputFileFullName = std::wstring(argv[2]);
		}
		else
		{
			outputFileFullName = prefix + L"_" + clKernelFileNameWSTR + L".h";
		}
		FILE *outputFile;
		WINError = _wfopen_s(&outputFile, outputFileFullName.c_str(), L"w+");
		if (WINError)
		{
			printf("Failed to open %ls\n", outputFileFullName.c_str());
			return WINError;
		}
		// Since MS has a maximum size for string literal, we need to check the file size
		std::wstring headerdoc = L"#pragma once\n#include <string>\n// This file is generated by CLKenelProprocessor, any changes made in this file will be lost\n";
		size_t incrementChunk = MAX_BLOCK_CHUNK;
		std::vector<std::wstring> partitionList;
		fprintf(outputFile, "%ls\n", headerdoc.c_str());
		size_t partitionCount = 0;
		std::wstring concateNateSource = L"";
		for (size_t i = 0; i < clKernlSource.size();i+=incrementChunk)
		{
			if ((clKernlSource.size() - i) < MAX_BLOCK_CHUNK)
			{
				incrementChunk = clKernlSource.size() - i;
			}
			else
			{
				incrementChunk = MAX_BLOCK_CHUNK;
			}
			fprintf(outputFile, "const std::string %ls%llu = R\"(%ls)\";\n", clKernelFileNameWSTR.c_str(), partitionCount, clKernlSource.substr(i, incrementChunk).c_str());
			if (incrementChunk < MAX_BLOCK_CHUNK)
			{
				concateNateSource += clKernelFileNameWSTR + std::to_wstring(partitionCount);
			}
			else
			{
				concateNateSource += clKernelFileNameWSTR + std::to_wstring(partitionCount) + L"+";
			}
			partitionCount++;
		}
		printf("Outputing: %ls\n", outputFileFullName.c_str());
		fprintf(outputFile, "const std::string %ls_Str =%ls;\nstatic const char* %ls = &%ls_Str[0u];\nconst size_t %lsCount= %ls_Str.size();\n", clKernelFileNameWSTR.c_str(), concateNateSource.c_str(),
			clKernelFileNameWSTR.c_str(), clKernelFileNameWSTR.c_str(), clKernelFileNameWSTR.c_str(), clKernelFileNameWSTR.c_str());
		fclose(outputFile);
	}
	else
	{
		printf("File is not a .cl file\n");
		return 1;
	}
	return 0;
}

